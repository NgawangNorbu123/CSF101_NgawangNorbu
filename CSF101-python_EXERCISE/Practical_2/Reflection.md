
# Documentation
Main Concepts Applied
In this practical, I explored:
- Recursion and iterationthrough Fibonacci sequence generation.


These exercises helped me understand not just *how* to code a solution, but also *how to think* about the problem systematically.

# Reflection

# What I Learned
I now understand the core differences between recursion and iteration. While recursion involves a function repeatedly calling itself until a base case is reached, iteration uses loops to execute steps until a specific condition is met.

I've noted that although recursive code can be cleaner and more elegant, iteration is generally preferred for its improved speed and memory efficiency.

Furthermore, designing pseudocode and flowcharts for simple tasks like calculating a rectangle's area or converting temperatures has proven invaluable. This planning stage has not only helped me think more logically but also solidified the importance of pre-planning any programming solution.

---

# Challenges and Solutions
I finally figured out my main problem with recursion: I didn't understand how the function stops! My program kept running forever because I forgot to include the base case (the rule that tells it to stop, like n=0 or n=1). Once I realized that recursion absolutely needs a stopping condition, it all clicked.
I also learned how useful planning is when I spotted small mistakes in my logic while writing pseudocodeâ€”things like using the wrong symbol for comparison versus setting a value. Looking at the flowchart helped me catch and fix those errors before I even started writing the actual computer code."
